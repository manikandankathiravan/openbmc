From e9717a53bf8abfaf9c63b4b258aafd9382505455 Mon Sep 17 00:00:00 2001
From: Manikandan Elumalai <manikandan.hcl.ers.epl@gmail.com>
Date: Mon, 10 Feb 2020 18:51:58 +0530
Subject: [PATCH] u-boot-host-console-handle

---
 board/aspeed/ast-g5/ast-g5.c | 188 +++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 188 insertions(+)

diff --git a/board/aspeed/ast-g5/ast-g5.c b/board/aspeed/ast-g5/ast-g5.c
index e67a4bf..833ce9b 100644
--- a/board/aspeed/ast-g5/ast-g5.c
+++ b/board/aspeed/ast-g5/ast-g5.c
@@ -16,8 +16,196 @@
 
 DECLARE_GLOBAL_DATA_PTR;
 
+#define MAX_NODES 4
+
+static void fan_init(void)
+{
+  u32 reg;
+
+  // enable PWM0 and PWM1 function pin
+  reg = __raw_readl(AST_SCU_BASE + 0x88);
+  reg |= 0x03;
+  __raw_writel(reg, AST_SCU_BASE + 0x88);
+
+  reg = __raw_readl(AST_SCU_BASE + 0x04);
+  reg &= ~0x200;
+  __raw_writel(reg, AST_SCU_BASE + 0x04);
+
+  // set PWM0 and PWM1 to 70%
+  __raw_writel(0x09435F05, AST_PWM_BASE + 0x04);
+  __raw_writel(0x43004300, AST_PWM_BASE + 0x08);
+  __raw_writel(0x00000301, AST_PWM_BASE + 0x00);
+}
+
+static int mux_init(void)
+{
+  u8 loc;
+  u32 reg, pwr_en;
+
+  reg = __raw_readl(AST_GPIO_BASE + 0x1E0);
+  loc = ((reg >> 20) & 0xF) % 5;
+
+  // USB MUX, P3V3 enable
+  // enable GPIOAB3,AB1 WDT reset tolerance
+  reg = __raw_readl(AST_GPIO_BASE + 0x18C);
+  reg |= 0xA000000;
+  __raw_writel(reg, AST_GPIO_BASE + 0x18C);
+  // set USB MUX, P3V3 enable
+  reg = __raw_readl(AST_GPIO_BASE + 0x1E0);
+  if (loc < MAX_NODES) {
+    pwr_en = __raw_readl(AST_GPIO_BASE + 0x70);
+    reg = (reg & ~0x8000000) | ((pwr_en & (1 << loc)) ? 0x2000000 : 0xA000000);
+  } else {
+    reg |= 0xA000000;
+  }
+  __raw_writel(reg, AST_GPIO_BASE + 0x1E0);
+  // set GPIOAB3,AB1 as output
+  reg = __raw_readl(AST_GPIO_BASE + 0x1E4);
+  reg |= 0xA000000;
+  __raw_writel(reg, AST_GPIO_BASE + 0x1E4);
+
+  // USB MUX
+  // enable GPIOE[5:4] WDT reset tolerance
+  reg = __raw_readl(AST_GPIO_BASE + 0x3C);
+  reg |= 0x30;
+  __raw_writel(reg, AST_GPIO_BASE + 0x3C);
+  // set USB MUX location
+  reg = __raw_readl(AST_GPIO_BASE + 0x20);
+  if (loc < MAX_NODES) {
+    reg = (reg & ~0x30) | (loc << 4);
+  }
+  __raw_writel(reg, AST_GPIO_BASE + 0x20);
+  // set GPIOE[5:4] as output
+  reg = __raw_readl(AST_GPIO_BASE + 0x24);
+  reg |= 0x30;
+  __raw_writel(reg, AST_GPIO_BASE + 0x24);
+
+  // VGA MUX
+  // enable GPIOJ[3:0] WDT reset tolerance
+  reg = __raw_readl(AST_GPIO_BASE + 0xAC);
+  reg |= 0xF00;
+  __raw_writel(reg, AST_GPIO_BASE + 0xAC);
+  // set VGA MUX location
+  reg = __raw_readl(AST_GPIO_BASE + 0x70);
+  if (loc < MAX_NODES) {
+    reg = (reg & ~0xC00);
+  }
+  __raw_writel(reg, AST_GPIO_BASE + 0x70);
+  // set GPIOJ[3:0] as output
+  reg = __raw_readl(AST_GPIO_BASE + 0x74);
+  reg |= 0xF00;
+  __raw_writel(reg, AST_GPIO_BASE + 0x74);
+
+  // PCIe Clk/Rst buffer
+  // enable GPIOB[7:4] WDT reset tolerance
+  reg = __raw_readl(AST_GPIO_BASE + 0x1C);
+  reg |= 0xF000;
+  __raw_writel(reg, AST_GPIO_BASE + 0x1C);
+  // set PCIe Clk/Rst buffer
+  reg = __raw_readl(AST_GPIO_BASE + 0x00);
+  __raw_writel(reg, AST_GPIO_BASE + 0x00);
+  // set GPIOB[7:4] as output
+  reg = __raw_readl(AST_GPIO_BASE + 0x04);
+  reg |= 0xF000;
+  __raw_writel(reg, AST_GPIO_BASE + 0x04);
+
+  return 0;
+}
+
+static int slot_12V_init(void)
+{
+  u32 slot_present_reg;
+  u32 slot_12v_reg;
+  u32 dir_reg;
+  u32 toler_reg;
+  uint8_t val_prim;
+  uint8_t val_ext;
+  int i;
+
+  //Read GPIOZ0~Z3 and AA0~AA3
+  slot_present_reg = __raw_readl(AST_GPIO_BASE + 0x1E0);
+  //Read GPIOO4~O7
+  slot_12v_reg = __raw_readl(AST_GPIO_BASE + 0x078);
+
+  for (i = 0; i < MAX_NODES; i++) {
+    val_ext = (slot_present_reg >> (2*MAX_NODES+i)) & 0x1;
+    val_prim = (slot_present_reg >> (4*MAX_NODES+i)) & 0x1;
+
+    if (val_prim || val_ext) {
+      slot_12v_reg &= ~(1<<(5*MAX_NODES+i));
+    } else {
+      slot_12v_reg |= (1<<(5*MAX_NODES+i));
+    }
+  }
+
+  //Set GPIOO4~O7 Watchdog reset tolerance
+  toler_reg = __raw_readl(AST_GPIO_BASE + 0x0FC);
+  toler_reg |= 0xF00000;
+  __raw_writel(toler_reg, AST_GPIO_BASE + 0x0FC);
+
+  //Configure GPIOO4~O7
+  __raw_writel(slot_12v_reg, AST_GPIO_BASE + 0x078);
+  dir_reg = __raw_readl(AST_GPIO_BASE + 0x07C);
+  dir_reg |= 0xF00000;
+  __raw_writel(dir_reg, AST_GPIO_BASE + 0x07C);
+  __raw_writel(slot_12v_reg, AST_GPIO_BASE + 0x078);
+
+  return 0;
+}
+
+static int slot_led_init(void)
+{
+  u32 reg, dir_reg;
+  u32 fan_latch;
+  u32 slot_present_reg;
+  uint8_t val_prim;
+  uint8_t val_ext;
+  int i;
+
+  // enable GPIOAC0~AC3, and AC7
+  reg = __raw_readl(AST_SCU_BASE + 0xAC);
+  reg &= ~0x8F;
+  __raw_writel(reg, AST_SCU_BASE + 0xAC);
+
+  // read GPIOH5
+  fan_latch = __raw_readl(AST_GPIO_BASE + 0x020) & 0x20000000;
+
+  //Read GPIOZ0~Z3 and AA0~AA3
+  slot_present_reg = __raw_readl(AST_GPIO_BASE + 0x1E0);
+
+  // configure GPIOAC0~AC3, and AC7
+  reg = __raw_readl(AST_GPIO_BASE + 0x1E8);
+
+  for (i = 0; i < MAX_NODES; i++) {
+    val_ext = (slot_present_reg >> (2*MAX_NODES+i)) & 0x1;
+    val_prim = (slot_present_reg >> (4*MAX_NODES+i)) & 0x1;
+
+    if (val_prim || val_ext)
+      reg &= ~(1 << i);
+    else
+      reg |= (1 << i);
+  }
+
+  reg = (fan_latch) ? (reg | 0x80) : (reg & ~0x8F);
+
+  dir_reg = __raw_readl(AST_GPIO_BASE + 0x1EC) | 0x8F;
+  __raw_writel(dir_reg, AST_GPIO_BASE + 0x1EC);
+  __raw_writel(reg, AST_GPIO_BASE + 0x1E8);
+
+  return 0;
+}
+
 int board_init(void)
 {
+        
+        fan_init();
+        printf("fan_init()\n");
+  	mux_init();
+	printf("mux_init()\n");
+  	slot_12V_init();
+        printf("slot_12V_init()\n");
+  	slot_led_init();
+	printf("slot_led_init()\n");
 	gd->bd->bi_boot_params = CONFIG_SYS_SDRAM_BASE + 0x100;
 	gd->flags = 0;
 
-- 
2.7.4

